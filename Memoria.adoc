= Memoria práctica Diseño Orientado a Objetos

Para esta práctica se busca analizar y diseñar el juego Mastermind
mediante distintas iteracciones en las que se van arreglando los fallos
hasta tener una aplicación funcional que cumpla una serie de características.

== Iteración 1
En esta primera iteración se introduce el juego Mastermind y se comienza
a realizar una primera versión del juego. +
El primer error que se realiza en esta
práctica es la no realización de un análisis y diseño, como podemos observar al ver
el diagrama de clases UML de la Figura 1.

|===
a|image::diagramaClasesIteracion1.png[]
|Figura 1
|===

.Si analizamos la mantenibilidad de este software podemos observar lo siguiente:
* En cuanto a su viscosidad debemos diferenciarla de dos formas:
** La viscosidad del diseño es alta ya que no contamos con un diseño definido de la solución
a esta implementación.
** La viscosidad del entorno, por otro lado, es bastante mejorable ya que el programa tarda en
compilar bastante la primera vez que se lanza teniendo en cuenta que son solo dos clases.
Si necesitasemos arreglar algún problema lógico (como la condición de un if) perderíamos alrededor de
cinco segundos en poder volver a probar el programa.
* Si analizamos la rigidez tenemos problemas de cambios. La clase combinación contiene actualmente
la combinación secreta como la posible combinación; por lo que si extrayeramos la posible combinación
a una clase nueva o como un atributo de la clase principal (clase Mastermind) tendríamos que realizar
cambios en cascada en la clase principal para poder cambiar todo el software y adaptarlo.
* En cuanto a la fragilidad, como está estrechamente relacionada con la rigidez si realizamos un cambio
tendremos problemas ya que es mucho más probable que el código deje de funcionar al tener que realizar
cambios en cascada. Podemos olvidar cambiar cualquier detalle que consiga estropear el software.
* Este software se debería considerar inmóvil debido a que no podemos reutilizar ninguna de sus partes
para otro proyecto ya que todo está construido en un mismo lugar, mezclando todas sus partes.

En resumen, durante esta iteración se ha creado un software que es viscoso, rígido, frágil e inmóvil;
por lo que en las siguientes iteracciones habrá que solucionar todos esos problemas ya que es un
software no mantenible.

== Iteración 2
En la segunda iteración se mejora el software, añadiendo más clases y refactorizando el código.
|===
a|image::diagramaClasesIteracion2.png[]
|Figura 2
|===
.Si analizamos la complejidad de este nuevo software:
* Viscosidad No
* Rigidez No
* Fragilidad No
* Inmovilidad No